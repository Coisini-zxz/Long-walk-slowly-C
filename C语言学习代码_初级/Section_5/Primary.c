#define _CRT_SECURE_NO_WARNINGS	1
#include <stdio.h>

int main()
{
	// Arithmetic_operator(); 
	// shift_operator();
	// Bitwise_operator();
	// eg1();
	// eg2();
	// Sturucture_vari();
	zhengxingup();
	return 0;
}

int Arithmetic_operator()
{
	// 算数操作符
	int a1 = 1 / 2; 
	printf("%d\n", a1);		// 0

	int a2 = 7 / 6;
	printf("%d\n", a2);		// 1

	float a3 = 7 / 6;
	printf("%f\n", a3);		// 1.000000

	float a4 = 7.0 / 6;
	printf("%f\n", a4);		// 1.166667

	int a5 = 5 % 2;
	printf("%d\n", a5);		// 1
	return 0;
	/*
	1. 除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。
	2. 对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
	3. % 操作符的两个操作数必须为整数。返回的是整除之后的余数。
	*/
}

int shift_operator()
{
	// 注：移位操作符的操作数只能是整数
	// 左移 右移 都不会改变a
	int a = 2;
	int b = a << 1;				// a的二进制向左移动一位 后面补0 
	printf("b = %d\n", b);

	// 右移操作符
	//                  --- 1. 算数右移 -> 右移丢弃 左边补符号位 
	//					 --- 2. 逻辑右移 -> 右移丢弃 左边补0
	int z = -1;
	// 当前右移操作符 使用的是 算数右移
	int c = z >> 1;				// a的二进制向左移动一位 后面补0
	printf("c = %d\n", c);
	return 0;
}

int Bitwise_operator()
{
	// 注：他们的操作数必须是整数 
	int a = 3;			// 00000000000000000000000000000011
	int b = 5;			// 00000000000000000000000000000101

	// 1.  &  -> 按位与 (二进制位)
	int c = a & b;  // 00000000000000000000000000000001 (按位对比 有0就为0 除非都不为0）
	printf("c = %d\n", c); // 1

	// 2.  |  -> 按位或
	int d = a | b;		// 00000000000000000000000000000111
	printf("d = %d\n", d); // 7

	// 3. ^  -> 按位异或 (相同为0 相异为1)
	int e = a ^ b;	// 00000000000000000000000000000110
	printf("e = %d\n", e); // 6

	// eg - 交换两个变量的值 且不能创建第三个变量
	int i = 4;
	int t = 6;
	printf("i = %d,t = %d\n", i, t);
	i = i ^ t;  //   i = i^t
	t = i ^ t;  //  t = i^t^t  = i
	i = i ^ t;  //   i = i^t^i^t^t = t
	//  妙蛙种子吃了妙脆角妙到家了！
	printf("i = %d,t = %d\n", i, t);

	// a ^ a = 0; 
	// 0 ^ a = a;
	return 0;
}

int eg1()
{
	int a = 13;
	// 00000000000000000000000000001101
	// 现在 想把 这组二进制位 某一位变成0或1 怎么做？ （比如把倒数第五位)

	// 00000000000000000000000000010000(1 << 4) 与这个 按位或 可得到
	a = a | (1 << 4);
	printf("a = %d\n", a);


	// 怎么改回来呢？
	a = a & ~(1 << 4);
	printf("a = %d\n", a);
	return 0;
}

int eg2()
{
	int a = -1;
	// 10000000000000000000000000000001 - 原码
	// 11111111111111111111111111111110 - 反码
	// 11111111111111111111111111111111 - 补码
	// ~ 按位取反
	int b = ~a;
	// 00000000000000000000000000000000
	printf("b = %d\n", b);
	return 0;
}

// 比较两个字符串 是否相等 不能用 == 
// 逗号表达式 - 要从做从左往右依次计算 但是整个表达式的结果是最后一个式子的结果


// 结构体
struct Stu
{
	char name[20];
	int age;
};

void print(struct Stu* ps)
{
	printf("name = %s   age = %d\n", (*ps).name, (*ps).age);
	//使用结构体指针访问指向对象的成员
	printf("name = %s   age = %d\n", ps->name, ps->age);
}

int Sturucture_vari()
{
	struct Stu s = { "zhangsan", 20 };
	print(&s);//结构体地址传参
	return 0;
}

// 整型提升
//               ---- 是按照变量的数据类型的符号位 来提升的
//                            1. 负数的整型提升 高位补符号位 1
//                            2. 正数的整型提升 高位补符号位 0
//                            3. 无符号整型提升 高位补 0
int zhengxingup()
{
	char a = 3;
	// 00000000000000000000000000000011
	// 00000011 -a

	char b = 127;
	// 00000000000000000000000001111111
	// 01111111 -b

	char c = a + b;
	printf("c = %d\n", c);
	// 发现 ab都是char类型 没有一个达到int的大小 - 这里就会发生整型提升
		// 00000000000000000000000000000011
		// 00000000000000000000000001111111
	    // 00000000000000000000000010000010
		// 10000010 - c
		// 11111111111111111111111110000010
		// 注意 因为是负数 此时得到的是 补码 （在屏幕上打印的是原码 内存中存储的是补码）
		// 原码 取反+1 得到 补码
		// 11111111111111111111111110000001(-1) - 1000000000000000000000000000000001111110(原码)
		// 1000000000000000000000000000000001111110 - 就是 -126
	return 0;
}