#include <stdio.h>

int main()
{
	// func0();
	// func1();
	// func2();
	// func3();
	func4();
	return 0;
}


struct S1
{
	char c1;
	int i;
	char c2;
};

struct S2
{
	char c1;
	int i;
	double d;
};

struct S3
{
	char c1;
	struct S2 s2;
	double d;
};


int func0()
{
	struct S1 s1 = { 0 };
	struct S2 s2 = { 0 };
	struct S3 s3 = { 0 };
	printf("%d\n", sizeof(s1)); // 12 
	printf("%d\n", sizeof(s2)); // 16
	printf("%d\n", sizeof(s3)); // 32
	return 0;
}

/*
结构体内存对齐


如何计算？
首先得掌握结构体的对齐规则：
1. 第一个成员在与结构体变量偏移量为0的地址处。
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
（VS中默认的值为8）
3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。（！！！）

为什么存在内存对齐?
大部分的参考资料都是如是说的：

1. 平台原因(移植原因)：
不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特
定类型的数据，否则抛出硬件异常

2. 性能原因：
数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访
问。

总体来说：
结构体的内存对齐是拿空间来换取时间的做法
*/


/*
那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：
   1. ---> 让占用空间小的成员尽量集中在一起
//例如：
struct S1
{
 char c1;
 int i;
 char c2;
};
struct S2
{
 char c1;
 char c2;
 int i;
};
S1和S2类型的成员一模一样，但是S1和S2所占空间的大小有了一些区别
*/


/*
2. --->修改默认对齐数

之前我们见过了 #pragma 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数。

#pragma pack(8)//设置默认对齐数为8
struct S1
{
 char c1;
 int i;
 char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
#pragma pack(1)//设置默认对齐数为1
struct S2
{
 char c1;
 int i;
 char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
int main()
{
	//输出的结果是什么？
	printf("%d\n", sizeof(struct S1));
	printf("%d\n", sizeof(struct S2));
	return 0;
}


	结论:
结构在对齐方式不合适的时候，可以自己更改默认对齐数。
*/

// offsetof 宏的实现
// 先介绍这个

#include <stddef.h>
int func1()
{
	printf("%d\n", offsetof(struct S3, c1));  // 0
	printf("%d\n", offsetof(struct S3, s2));  // 8
	printf("%d\n", offsetof(struct S3, d));   // 24
	return 0;
}


// 结构体传参

struct S
{
	int data[1000];
	int num;
};
struct S s = { {1,2,3,4}, 1000 };

//结构体传参
void print1(struct S s)
{
	printf("%d\n", s.num);
}
//结构体地址传参
void print2(struct S* ps)
{
	printf("%d\n", ps->num);
}

int func2()
{
	print1(s);  //传结构体
	print2(&s); //传地址
	return 0;
}

/*
上面的 print1 和 print2 函数哪个好些？
答案是：首选print2函数。
原因：
函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销
如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降

结论：
结构体传参的时候，要传结构体的地址
*/

// 位段
/*
位段
结构体讲完就得讲讲结构体实现 位段 的能力。
2.1 什么是位段
位段的声明和结构是类似的，有两个不同：
1.位段的成员必须是 int、unsigned int 或signed int 。
2.位段的成员名后边有一个冒号和一个数字。




*/

// eg
struct A
{
	int _a : 2;  // _a 成员占 2个比特位
	int _b : 5;  // 5
	int _c : 10;  // 10 
	int _d : 30; // 30 
};
// 2+5+10+30 = 47bit
// 但是为什么输出 8byte 呢 也就是64bit


int func3()
{
	// A就是一个位段类型。
	// 那位段A的大小是多少？
	printf("%d\n", sizeof(struct A)); //8
	return 0;
}
/*
位段的内存分配
1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段
*/

// 有什么意义呢
/*
一定程度上 在帮我们节省空间
eg: 
性别   ---> 一共3个bit 足够
{'男':00,'
女':01,
保密'10'} 

回看
struct A
{
	// 开辟了四个字节 32bit
	int _a : 2;  // _a 成员占 2个比特位
	int _b : 5;  // 5
	int _c : 10;  // 10
	// 剩15个bit 
	int _d : 30; // 30
	// 但是	int _d : 33;是错误的 一共4byte32bit 不能超过32
	// 还有一个点
	---> 剩15bit 但是_d是30bit 到底是用没用那15个 无从得知 C没有规定 所以有了第三点p219
};
*/

/*
视频+ppt
要看懂理解
*/

/*

位段的跨平台问题
1. int 位段被当成有符号数还是无符号数是不确定的。
2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机
器会出问题。
3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是
舍弃剩余的位还是利用，这是不确定的。

总结：
跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在
*/


/*
枚举的优点
为什么使用枚举？
我们可以使用 #define 定义常量，为什么非要使用枚举？
枚举的优点：
1. 增加代码的可读性和可维护性
2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
3. 防止了命名污染（封装）
4. 便于调试
5. 使用方便，一次可以定义多个常量
*/

/*
联合（共用体）
联合类型的定义
联合也是一种特殊的自定义类型
这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。
比如：p293


联合的特点
联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联
合至少得有能力保存最大的那个成员）


联合大小的计算
联合的大小至少是最大成员的大小。
当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍
*/


int func4()
{
	//联合类型的声明
	union Un
	{
		char c;
		int i;
	};
	//联合变量的定义
	union Un un;

	//计算两个变量的大小
	printf("%d\n", sizeof(un));   // 4
	printf("%p\n", &un);			// 00000069E64FF9D4
	printf("%p\n", &(un.c));	   // 00000069E64FF9D4
	printf("%p\n", &(un.i));      // 00000069E64FF9D4
}