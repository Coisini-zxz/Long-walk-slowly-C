#include <stdio.h>

int main()
{
	// func1(); // Release版本会对代码优化以及越界访问造成的问题
	// func2(); // 整数在内存中的存储
	// func3(); // 大端字节序 - 小端字节序
	// practice0(); // 题目 以下代码会输出什么？
	practice1();
	return 0;
}


// Release版本是如何优化的呢？
int func1()
{
	//int i = 0;
	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//for (i = 0; i <= 12; i++)
	//{
	//	arr[i] = 0;
	//	printf("Az\n");

	//}
	// 以上 会报错(或者产生死循环(不同ide不同)) 因为什么呢？
	/*
	i, arr 是局部变量 ---> 局部变量是放在栈区上的
	---> 而栈区的使用习惯是先用高地址再用低地址
	---> 数组随之下标的增长 地址是由低到高变化的
	看ppt的图 理解
	*/
	// 如果使用 Release 不会报错或者死循环
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	// 查看 debug跟release版本 下的区别
	printf("%p\n", &i);
	printf("%p\n", &arr[2]);
	return 0;
}


// 整数在内存中的存储
int func2()
{
	int a = -10;  // f6 ff ff ff 
	// 先写出 -10 的原码(先写符号位 即最高位) 
	// ---> (1) 10000000000000000000000000001010 ---> 根据数值直接写出的二进制 即为 原码
	// ---> (2) 11111111111111111111111111110101 ---> 原码符号位不变其他位取反 即为 反码
	// ---> (3) 11111111111111111111111111110110 ---> 反码 + 1 即为补码
	// ---> (4) FF FF FF FF F6 跟上面对比 发现 存的补码

	// 为什么放补码呢 
	// 1-1 ---> 1+(-1) ---> CPU无法进行加法运算
	// 00000000000000000000000000000001 + 10000000000000000000000000000001(原码) = 10000000000000000000000000000010 ?? 1-1 != -2啊
	// 00000000000000000000000000000001 + 11111111111111111111111111111111(补码) = 00000000000000000000000000000000 = 0 正确
	// 其实是 = 100000000000000000000000000000000 33个bit 但实际上只能存 32bit 所以1进位上去了 剩下 32bit全是0 即结果为0
	return 0;
}

/*
数据在内存中以二进制形式存储 (存的补码！！！)
对于整数来说： 整数二进制有三种形式  ---> 原码 补码 反码
而 
正整数三者相同
负整数三者需要计算
*/


// 大端字节序 - 小端字节序
int func3()
{
	int a = -10;  // f6 ff ff ff 
	int b = 10;  // 0a 00 00 00
	// ？？？ 你会发现 怎么是反着存的
	int c = 0x11223344;  // 44 33 22 11
	// 在内存中 如果
	//  11 22 33 44 ---> 大端字节序
	//  44 33 22 11 ---> 小端字节序
	return 0;
}

/*
什么是大端小端
---> 大端存储模式 ： 是指数据的低位 保存在内存的高地址中，   而数据的高位 保存在内存的低地址中
---> 小端存储模式 ： 是指数据的低位 保存在内存的低地址中，   而数据的高位 保存在内存的高地址中
*/


// 题目 以下代码会输出什么？
int practice0() 
{
	char a = -1;
	signed  char b = -1;
	unsigned char c = -1;
	printf("a = %d\nb = %d\nc = %d", a, b, c);
	/*
	 解题
	 int -1 ---> 10000000000000000000000000000001 --->  11111111111111111111111111111110 ---> 11111111111111111111111111111111
	 而char类型 权限只有两个字节 所以 11111111 而pringf的是%d 打印整型 所以发生了整型提升 ---> 11111111111111111111111111111111(补码)
	  所以 a b 还是-1 
	  而c unsigined 类型 所以认为11111111没有符号位 整型提升后 00000000000000000000000011111111 正数 原反补 相同 所以为255
	*/
	char a = -128;
	// 11111111111111111111111110000000 (补码)
	// 10000000 ---> 整型提升后 ---> 11111111111111111111111110000000
	// %u 无符号 认为这是一个正数 即为11111111111111111111111110000000
	printf("%u\n", a);

	// char 类型变量的取值范围
	// char 在内存中 [00000000 ~ 01111111]+[10000000~11111111] 即为 [1~127]+[ -1 ~ -127] + [-128]   ---> [-128 ~ 127] 范围 
	// 注意 可以看到 10000000 无法再-1了 所以机器在看到这串时 规定会被直接解析为 -128 ！
	return 0;
}



int practice1()
{
	int i = -20;
	unsigned int j = 10;
	printf("%d\n", i + j); // -10  ！！
	return 0;
}

int practice2()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
	}
	return 0;
	// 死循环 undesigned 最少也是0 不可能<0 而条件中又有 = 0 这个条件 所以死循环
}

int practice3()
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	// -1 -2 -3 ~~~ -127 -128 127 126 ~~~ 3 2 1 -1 -2 -3 ~~~ -127 -128 127 ~~
	printf("%d", strlen(a));
	return 0;
}	