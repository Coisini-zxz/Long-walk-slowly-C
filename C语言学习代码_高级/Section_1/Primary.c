#include <stdio.h>

int main()
{
	// func1(); // Release版本会对代码优化以及越界访问造成的问题
	// func2(); // 整数在内存中的存储
	// func3(); // 大端字节序 - 小端字节序
	// practice0(); // 题目 以下代码会输出什么？
	// practice1();
	// practice2();
	// practice3();
	// practice4();
	// func4(); // 浮点数
	// practice5(); // 怎么放 怎么取
	return 0;
}


// Release版本是如何优化的呢？
int func1()
{
	//int i = 0;
	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//for (i = 0; i <= 12; i++)
	//{
	//	arr[i] = 0;
	//	printf("Az\n");

	//}
	// 以上 会报错(或者产生死循环(不同ide不同)) 因为什么呢？
	/*
	i, arr 是局部变量 ---> 局部变量是放在栈区上的
	---> 而栈区的使用习惯是先用高地址再用低地址
	---> 数组随之下标的增长 地址是由低到高变化的
	看ppt的图 理解
	*/
	// 如果使用 Release 不会报错或者死循环
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	// 查看 debug跟release版本 下的区别
	printf("%p\n", &i);
	printf("%p\n", &arr[2]);
	return 0;
}


// 整数在内存中的存储
int func2()
{
	int a = -10;  // f6 ff ff ff 
	// 先写出 -10 的原码(先写符号位 即最高位) 
	// ---> (1) 10000000000000000000000000001010 ---> 根据数值直接写出的二进制 即为 原码
	// ---> (2) 11111111111111111111111111110101 ---> 原码符号位不变其他位取反 即为 反码
	// ---> (3) 11111111111111111111111111110110 ---> 反码 + 1 即为补码
	// ---> (4) FF FF FF FF F6 跟上面对比 发现 存的补码

	// 为什么放补码呢 
	// 1-1 ---> 1+(-1) ---> CPU无法进行加法运算
	// 00000000000000000000000000000001 + 10000000000000000000000000000001(原码) = 10000000000000000000000000000010 ?? 1-1 != -2啊
	// 00000000000000000000000000000001 + 11111111111111111111111111111111(补码) = 00000000000000000000000000000000 = 0 正确
	// 其实是 = 100000000000000000000000000000000 33个bit 但实际上只能存 32bit 所以1进位上去了 剩下 32bit全是0 即结果为0
	return 0;
}

/*
数据在内存中以二进制形式存储 (存的补码！！！)
对于整数来说： 整数二进制有三种形式  ---> 原码 补码 反码
而 
正整数三者相同
负整数三者需要计算
*/


// 大端字节序 - 小端字节序
int func3()
{
	int a = -10;  // f6 ff ff ff 
	int b = 10;  // 0a 00 00 00
	// ？？？ 你会发现 怎么是反着存的
	int c = 0x11223344;  // 44 33 22 11
	// 在内存中 如果
	//  11 22 33 44 ---> 大端字节序
	//  44 33 22 11 ---> 小端字节序
	return 0;
}

/*
什么是大端小端
---> 大端存储模式 ： 是指数据的低位 保存在内存的高地址中，   而数据的高位 保存在内存的低地址中
---> 小端存储模式 ： 是指数据的低位 保存在内存的低地址中，   而数据的高位 保存在内存的高地址中
*/


// 题目 以下代码会输出什么？
int practice0() 
{
	char a = -1;
	signed  char b = -1;
	unsigned char c = -1;
	printf("a = %d\nb = %d\nc = %d", a, b, c);
	/*
	 解题
	 int -1 ---> 10000000000000000000000000000001 --->  11111111111111111111111111111110 ---> 11111111111111111111111111111111
	 而char类型 权限只有两个字节 所以 11111111 而pringf的是%d 打印整型 所以发生了整型提升 ---> 11111111111111111111111111111111(补码)
	  所以 a b 还是-1 
	  而c unsigined 类型 所以认为11111111没有符号位 整型提升后 00000000000000000000000011111111 正数 原反补 相同 所以为255
	*/
	char e = -128;
	// 11111111111111111111111110000000 (补码)
	// 10000000 ---> 整型提升后 ---> 11111111111111111111111110000000
	// %u 无符号 认为这是一个正数 即为11111111111111111111111110000000
	printf("%u\n", e);

	// char 类型变量的取值范围
	// char 在内存中 [00000000 ~ 01111111]+[10000000~11111111] 即为 [1~127]+[ -1 ~ -127] + [-128]   ---> [-128 ~ 127] 范围 
	// 注意 可以看到 10000000 无法再-1了 所以机器在看到这串时 规定会被直接解析为 -128 ！
	return 0;
}



int practice1()
{
	int i = -20;
	unsigned int j = 10;
	printf("%d\n", i + j); // -10  ！！
	return 0;
}

int practice2()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
	}
	return 0;
	// 死循环 
	// undesigned 最少也是0 不可能<0 而条件中又有 = 0 这个条件 所以死循环
}

int practice3()
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	// -1 -2 -3 ~~~ -127 -128 127 126 ~~~ 3 2 1 0  -1 -2 -3 ~~~ -127 -128 127 ~~
	printf("%d", strlen(a));
	return 0;
	/*
	理解char的范围那个func 去看板书那个圈
	*/
	/*
	strlen 要找到 '/0' 结束 ---> 而 '/0'的ascll码值就是 0 ---> 也就是说找到 0 结束
	所以  128 + 127 = 255 
	巧计口诀 ---> 超出范围的数据如果是指正数 则减去 256 ， 如果是负数 则加上 256
	*/
}

int practice4()
{
	unsigned char i = 0;
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
	/*
	死循环
	无符号char范围[0~255]
	跟练习2一个道理
	*/
}

// 浮点数

#include <limits.h>
int func4()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n); // 9
	printf("*pFloat的值为：%f\n", *pFloat);   // 此时是浮点数的视角去拿的 *float是拿四个byte ，*char是一个
	*pFloat = 9.0;  // 以浮点数的视角存储， 存储9.0
	printf("num的值为：%d\n", n); // 以整数的视角去拿
	printf("*pFloat的值为：%f\n", *pFloat); // 9.0
	// 整型放整型拿 浮点数放浮点数拿 都没问题 但混着就有问题了
	return 0;
}
/*
num 和 *pFloat 在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？
要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法。
详细解读：
根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：
(-1)^S * M * 2^E
(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
M表示有效数字，大于等于1，小于2。
2^E表示指数位。

eg : 
浮点数：
	十进制 - 5.5 
	二进制 - 101.1 ---> 1.011*2^2 ---> (-1)^0*1.011*2^2
	s = 0; M=1.011; E=2
*/

int practice5()
{
	float f = 5.5f;
	// 101.1 ---> 1.011*2^2 --->  s=0, M=011,E=2 ---> s=0; M=011; E=2+127
	// 0(s) 10000001(E) 011(M) 00000000000000000000(补0) ---> 0100 0000 1011 0000 0000 0000 0000 0000 ---> 40 b0 00 00 
	// 调试 查看是否 一样
	// 00 00 b0 40(小端存储) 一样！
	return 0;
}

/*

指数E从内存中取出还可以再分成三种情况：

1. E不全为0或不全为1
这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将
有效数字M前加上第一位的1。
比如：
0.5（1 / 2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为
1.0 * 2 ^ (-1)，其阶码为 - 1 + 127 = 126，表示为
01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进
制表示形式为 : 0 01111110 00000000000000000000000

2. E全为0
这时，浮点数的指数E等于1 - 127（或者1 - 1023）即为真实值，
有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于
0的很小的数字。

3. E全为1
这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；

*/
// 回头看func4
// p187  
// 0 00000000 00000000000000000001001 ---> 0.000000000000000000001001 * 2^(-126) ---> 0.000000

// p189 
// 0 10000010 00100000000000000000000 ---> 01000001000100000000000000000000 ---> 1091567616